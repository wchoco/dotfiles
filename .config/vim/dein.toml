[[plugins]] # plugin manager
repo = "Shougo/dein.vim"

[[plugins]] # asynchronous
repo = "Shougo/vimproc.vim"
build = "make"


[[plugins]] # directory tree
repo = "scrooloose/nerdtree"
hook_add = """
    nnoremap <silent><C-n> :NERDTreeToggle<CR>
    let g:NERDTreeShowBookmarks = 1
    let g:NERDTreeShowHidden = 1
    autocmd bufenter * if (winnr("$") == 1 && exists("b:NERDTree") && b:NERDTree.isTabTree()) | q | endif
"""

[[plugins]] # comment out
repo = "tyru/caw.vim"
hook_add = """
    nmap <Leader>c <Plug>(caw:hatpos:toggle)
    vmap <Leader>c <Plug>(caw:hatpos:toggle)
    nmap <Leader>, <Plug>(caw:zeropos:toggle)
    vmap <Leader>, <Plug>(caw:zeropos:toggle)
"""

[[plugins]] # auto-complete
repo = "Shougo/deoplete.nvim"
hook_add = """
    if !has('nvim')
      call dein#add('roxma/nvim-yarp')
      call dein#add('roxma/vim-hug-neovim-rpc')
    endif

    let g:deoplete#enable_at_startup = 1
    inoremap <expr><S-TAB>  pumvisible() ? "\<C-p>" : "\<C-h>"
    inoremap <expr><tab> pumvisible() ? "\<C-n>" :
    \ neosnippet#expandable_or_jumpable() ?
    \    "\<Plug>(neosnippet_expand_or_jump)" : "\<tab>"

    inoremap <expr><BS> deoplete#smart_close_popup()."\<C-h>"

    inoremap <expr><C-g>       deoplete#refresh()
    inoremap <silent><expr><C-l>       deoplete#complete_common_string()

    inoremap <silent> <CR> <C-r>=<SID>my_cr_function()<CR>
    function! s:my_cr_function() abort
      return deoplete#cancel_popup() . "\<CR>"
    endfunction

    inoremap <expr> '  pumvisible() ? deoplete#close_popup() : "'"

    let g:deoplete#keyword_patterns = {}
    let g:deoplete#keyword_patterns._ = '[a-zA-Z_]\k*\(?'
    let g:deoplete#keyword_patterns.tex = '[^\w|\s][a-zA-Z_]\w*'

    let g:deoplete#omni#input_patterns = {}
    let g:deoplete#omni#input_patterns.python = ''
    let g:deoplete#omni#functions = {}
    let g:deoplete#enable_refresh_always = 0
    let g:deoplete#enable_camel_case = 1

    let g:deoplete#skip_chars = ['(', ')']
    set completeopt-=preview
"""

[[plugins]] # run code
repo = "thinca/vim-quickrun"
hook_add = """
    let g:quickrun_config = get(g:, "quickrun_config", {})
    let g:quickrun_config._ = {
        \ "runner": "vimproc",
        \ "runner/vimproc/updatetime": 60,
        \ "outputter": "error",
        \ "outputter/error/success": "buffer",
        \ "outputter/error/error": "quickfix",
        \ "outputter/buffer/split": "rightbelow 8sp",
        \ "outputter/buffer/close_on_empty": 1,
        \ }
"""

[[plugins]] # matcher of denite
repo = 'nixprime/cpsm'
build = 'env PY3=ON ./install.sh'

[[plugins]] # file recently use
repo = 'Shougo/neomru.vim'

[[plugins]] # record yank
repo = 'Shougo/neoyank.vim'

[[plugins]] # file manager
repo = "Shougo/denite.nvim"
hook_post_update = """
    if executable('rg')
      call denite#custom#var('file_rec', 'command',
            \ ['rg', '--files', '--glob', '!.git' '--glob', '!__pycache__'])
      call denite#custom#var('grep', 'command', ['rg'])
    endif
    call denite#custom#source('file_rec', 'matchers', ['matcher_cpsm'])
"""
hook_add = """
    nmap [Denite] <Nop>
    nmap <C-u> [Denite]
    nmap <silent> [Denite]<C-u> <Nop>
    nmap <silent> [Denite]<C-t> :<C-u>Denite filetype<CR>
    nmap <silent> [Denite]<C-p> :<C-u>DeniteProjectDir file_rec<CR>
    nmap <silent> [Denite]<C-f> :<C-u>DeniteBufferDir file_rec<CR>
    nmap <silent> [Denite]<C-d> :<C-u>DeniteProjectDir directory_rec<CR>
    nmap <silent> [Denite]<C-b> :<C-u>Denite buffer<CR>
    nmap <silent> [Denite]<C-l> :<C-u>Denite line<CR>
    nmap <silent> [Denite]<C-g> :<C-u>DeniteProjectDir grep<CR>
    nmap <silent> [Denite]<C-w> :<C-u>DeniteCursorWord grep<CR>
    nmap <silent> [Denite]<C-m> :<C-u>Denite file_mru<CR>
    nmap <silent> [Denite]<C-y> :<C-u>Denite neoyank<CR>
    nmap <silent> [Denite]<C-r> :<C-u>Denite -resume<CR>
    nmap <silent> [Denite]; :<C-u>Denite -resume -immediately -select=+1<CR>
    nmap <silent> [Denite], :<C-u>Denite -resume -immediately -select=-1<CR>
    nmap <silent> [Denite]<C-h> :<C-u>call denite#start([{'name': 'file_rec', 'args': ['~']}])<CR>

    " customize rc
    let s:menus = {}
    let s:menus.rc = {'description': 'rc files'}
    let s:menus.rc.file_candidates = [\
        ['zshrc', '~/.zshrc'],\
        ['zshrc.local', '~/.zshrc.local'],\
        ['vimrc', '~/.vimrc'],\
        ['config', '~/.config']\
    ]
    call denite#custom#var('menu', 'menus', s:menus)
    nmap <silent> [Denite]<C-s> :<C-u>Denite menu:rc<CR>

    " customize ignore globs
    call denite#custom#source('file_rec', 'matchers', ['matcher_ignore_globs', 'matcher_cpsm'])
    call denite#custom#filter('matcher_ignore_globs', 'ignore_globs',
          \ [
          \ '.git/', 'build/', '__pycache__/',
          \ 'images/', '*.o', '*.make', '*.pyc',
          \ '*.min.*', 'node_modules/',
          \ 'img/', 'fonts/'])
"""

[[plugins]] # git cliant
repo = "tpope/vim-fugitive"
hook_add = """
    nmap <silent> <Leader>s :<C-u>Gstatus<CR>
    nmap <silent> <Leader>d :<C-u>Gdiff<CR>
    nmap <silent> <Leader>b :<C-u>Gblame<CR>
    nmap <silent> <Leader>l :<C-u>Glog<CR>
"""

[[plugins]] # show git change
repo = "airblade/vim-gitgutter"

[[plugins]] # indent guides
repo = "Yggdroot/indentLine"
hook_add = """
    let g:indentLine_color_term = 008
    let g:indentLine_char = "¦"
    nmap <silent> <C-j> :IndentLinesToggle<CR>:set number!<CR>
"""

[[plugins]] # snippet
repo = "Shougo/neosnippet.vim"
hook_add = """
    imap <C-l> <Plug>(neosnippet_expand_or_jump)
    smap <C-l> <Plug>(neosnippet_expand_or_jump)
    xmap <C-l> <Plug>(neosnippet_expand_target)
    if has("conceal")
        set conceallevel=2 concealcursor=niv
    endif
    let g:neosnippet#snippets_directory="~/.config/vim/snippets/"
"""

[[plugins]] # snippet list
repo = "Shougo/neosnippet-snippets"

[[plugins]] # show space
repo = "bronson/vim-trailing-whitespace"

[[plugins]] # manage bracket
repo = "machakann/vim-sandwich"

[[plugins]] # status line
repo = "itchyny/lightline.vim"
hook_add = """
    set noshowmode
    let g:lightline = {
        \ 'colorscheme': 'wombat',
        \ 'mode_map': {'c': 'NORMAL'},
        \ 'active': {
        \   'left': [ [ 'mode', 'paste' ], [ 'fugitive', 'filename' ] ],
        \   'right': [ [ 'lineinfo' ], ['percent'], [ 'ale_error', 'ale_warning', 'ale_ok', 'char_code', 'fileencoding', 'filetype' ] ]
        \ },
        \ 'component_function': {
        \   'modified': 'LightlineModified',
        \   'readonly': 'LightlineReadonly',
        \   'fugitive': 'LightlineFugitive',
        \   'filename': 'LightlineFilename',
        \   'filetype': 'LightlineFiletype',
        \   'fileencoding': 'LightlineFileencoding',
        \   'mode': 'LightlineMode',
        \   'char_code': 'LightLineCharCode'
        \ },
        \ 'component_expand': {
        \   'ale_error': 'LightLineAleError',
        \   'ale_warning': 'LightLineAleWarning',
        \   'ale_ok': 'LightLineAleOk',
        \ },
        \ 'component_type': {
        \   'ale_error': 'error',
        \   'ale_waring': 'waring',
        \   'ale_ok': 'ok',
        \ },
    \ }
    augroup LightLineOnALE
      autocmd!
      autocmd User ALELint call lightline#update()
    augroup END

    function! LightlineModified()
      return &ft =~ 'help\|vimfiler\|gundo' ? '' : &modified ? '+' : &modifiable ? '' : '-'
    endfunction

    function! LightlineReadonly()
      return &ft !~? 'help\|vimfiler\|gundo' && &readonly ? 'x' : ''
    endfunction

    function! LightlineFilename()
      if winwidth(0) > 120
        return ('' != LightlineReadonly() ? LightlineReadonly() . ' ' : '') .
              \ (&ft == 'denite' ? LightLineDenite() :
              \  &ft == 'vimshell' ? vimshell#get_status_string() :
              \ '' != expand('%') ? expand('%:~') : '[No Name]') .
              \ ('' != LightlineModified() ? ' ' . LightlineModified() : '')
      else
        return ('' != LightlineReadonly() ? LightlineReadonly() . ' ' : '') .
              \ (&ft == 'denite' ? LightLineDenite() :
              \  &ft == 'vimshell' ? vimshell#get_status_string() :
              \ '' != expand('%') ? expand('%:t') : '[No Name]') .
              \ ('' != LightlineModified() ? ' ' . LightlineModified() : '')
      endif
    endfunction

    function! LightlineFugitive()
      if &ft !~? 'vimfiler\|gundo' && exists('*fugitive#head')
        return fugitive#head()
      else
        return ''
      endif
    endfunction

    function! LightLineDenite()
      let mode_str = substitute(denite#get_status_mode(), "-\\| ", "", "g")
      call lightline#link(tolower(mode_str[0]))
      return mode_str
    endfunction

    function! LightlineFiletype()
      return winwidth(0) > 60 ? (&filetype !=# '' ? &filetype : 'no ft') : ''
    endfunction

    function! LightlineFileencoding()
      return winwidth(0) > 60 ? (&fenc !=# '' ? &fenc : &enc) : ''
    endfunction

    function! LightlineMode()
      return winwidth(0) > 60 ? lightline#mode() : lightline#mode()[0]
    endfunction

    function! LightLineCharCode() abort
      if winwidth(0) <= 120
        return ''
      endif
      " if char on cursor is `Λ̊`, :ascii returns below.
      " <Λ> 923, 16進数 039b, 8進数 1633 < ̊> 778, 16進数 030a, 8進数 1412
      redir => l:tmp | silent! ascii | redir END
      let l:chars = []
      call substitute(l:tmp, '<.>\s\+\d\+,\s\+\S\+ \x\+,\s\+\S\+ \d\+', '\=add(l:chars, submatch(0))', 'g')
      if len(l:chars) == 0
        return ''
      endif
      let l:ascii = []
      for l:c in l:chars
        let l:m = matchlist(l:c, '<\(.\)>\s\+\d\+,\s\+\S\+ \(\x\+\)')
        if len(l:m) > 0
          call add(l:ascii, printf('%s %s', l:m[1], l:m[2]))
        endif
      endfor
      return join(l:ascii, ', ')
    endfunction

    function! LightLineAleError() abort
      return s:ale_string(0)
    endfunction

    function! LightLineAleWarning() abort
      return s:ale_string(1)
    endfunction

    function! LightLineAleOk() abort
      return s:ale_string(2)
    endfunction

    function! s:ale_string(mode)
      if !exists('g:ale_buffer_info')
        return ''
      endif

      let l:buffer = bufnr('%')
      let l:counts = ale#statusline#Count(l:buffer)
      let [l:error_format, l:warning_format, l:no_errors] = g:ale_statusline_format

      if a:mode == 0 " Error
        let l:errors = l:counts.error + l:counts.style_error
        return l:errors ? printf(l:error_format, l:errors) : ''
      elseif a:mode == 1 " Warning
        let l:warnings = l:counts.warning + l:counts.style_warning
        return l:warnings ? printf(l:warning_format, l:warnings) : ''
      endif

      return l:counts.total == 0? l:no_errors: ''
    endfunction
"""
